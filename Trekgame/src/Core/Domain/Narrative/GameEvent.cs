using StarTrekGame.Domain.SharedKernel;

namespace StarTrekGame.Domain.Narrative;

/// <summary>
/// Represents a game event generated by the Game Master engine.
/// Events can trigger choices, effects, and story arcs.
/// </summary>
public class GameEvent : Entity
{
    public string Title { get; private set; }
    public string Description { get; private set; }
    public EventCategory Category { get; private set; }
    public EventScope Scope { get; private set; }
    public int TurnGenerated { get; private set; }
    public bool IsResolved { get; private set; }
    public Guid? TargetEmpireId { get; private set; }
    public Guid? TargetSystemId { get; private set; }

    private readonly Dictionary<string, object> _data = new();
    private readonly List<EventChoice> _choices = new();
    private readonly List<EventEffect> _effects = new();

    public IReadOnlyDictionary<string, object> Data => _data;
    public IReadOnlyList<EventChoice> Choices => _choices.AsReadOnly();
    public IReadOnlyList<EventEffect> Effects => _effects.AsReadOnly();

    private GameEvent() { } // EF Core

    public GameEvent(
        string title,
        string description,
        EventCategory category,
        EventScope scope,
        Dictionary<string, object>? data = null)
    {
        Title = title ?? throw new ArgumentNullException(nameof(title));
        Description = description ?? string.Empty;
        Category = category;
        Scope = scope;

        if (data != null)
        {
            foreach (var kvp in data)
                _data[kvp.Key] = kvp.Value;
        }
    }

    /// <summary>
    /// Constructor that accepts EventType and maps to EventCategory
    /// </summary>
    public GameEvent(
        string title,
        string description,
        EventType type,
        EventScope scope)
        : this(title, description, MapEventType(type), scope)
    {
    }

    private static EventCategory MapEventType(EventType type) => type switch
    {
        EventType.AnomalyDiscovered => EventCategory.Exploration,
        EventType.TradeOpportunity => EventCategory.Economic,
        EventType.DiplomaticIncident => EventCategory.Diplomatic,
        EventType.PirateAttack => EventCategory.Military,
        EventType.NaturalDisaster => EventCategory.Crisis,
        EventType.TechnologyDiscovered => EventCategory.Research,
        EventType.ColonialUnrest => EventCategory.Population,
        EventType.FirstContact => EventCategory.Diplomatic,
        _ => EventCategory.Narrative
    };

    public void SetTarget(Guid? empireId = null, Guid? systemId = null)
    {
        TargetEmpireId = empireId;
        TargetSystemId = systemId;
    }

    public void AddChoice(EventChoice choice)
    {
        _choices.Add(choice);
    }

    public void AddEffect(EventEffect effect)
    {
        _effects.Add(effect);
    }

    public T? GetData<T>(string key)
    {
        if (_data.TryGetValue(key, out var value) && value is T typedValue)
            return typedValue;
        return default;
    }

    public void Resolve(string? choiceId = null)
    {
        IsResolved = true;
        // Apply effects based on choice...
    }
}

/// <summary>
/// A choice the player can make in response to an event.
/// </summary>
public class EventChoice : ValueObject
{
    public string Id { get; }
    public string Text { get; }
    public string Tooltip { get; }
    public IReadOnlyList<EventEffect> Effects { get; }
    public IReadOnlyList<EventRequirement> Requirements { get; }

    public EventChoice(
        string id,
        string text,
        string tooltip,
        List<EventEffect>? effects = null,
        List<EventRequirement>? requirements = null)
    {
        Id = id;
        Text = text;
        Tooltip = tooltip;
        Effects = (effects ?? new List<EventEffect>()).AsReadOnly();
        Requirements = (requirements ?? new List<EventRequirement>()).AsReadOnly();
    }

    public bool CanChoose(Empire.Empire empire)
    {
        return Requirements.All(r => r.IsMet(empire));
    }

    protected override IEnumerable<object?> GetEqualityComponents()
    {
        yield return Id;
    }
}

/// <summary>
/// An effect that happens as a result of an event or choice.
/// </summary>
public record EventEffect(
    EffectType Type,
    string TargetType,  // "Empire", "System", "Fleet", etc.
    Guid? TargetId,
    Dictionary<string, object> Parameters
)
{
    public static EventEffect ResourceChange(decimal credits = 0, decimal dilithium = 0) =>
        new(EffectType.ResourceChange, "Empire", null, new Dictionary<string, object>
        {
            ["Credits"] = credits,
            ["Dilithium"] = dilithium
        });

    public static EventEffect RelationChange(Guid otherEmpireId, int delta) =>
        new(EffectType.RelationChange, "Empire", null, new Dictionary<string, object>
        {
            ["OtherEmpireId"] = otherEmpireId,
            ["Delta"] = delta
        });

    public static EventEffect SpawnFleet(Guid systemId, int strength) =>
        new(EffectType.SpawnEntity, "System", systemId, new Dictionary<string, object>
        {
            ["EntityType"] = "Fleet",
            ["Strength"] = strength
        });

    public static EventEffect TriggerArc(string arcId) =>
        new(EffectType.TriggerStoryArc, "Game", null, new Dictionary<string, object>
        {
            ["ArcId"] = arcId
        });
}

public enum EffectType
{
    ResourceChange,
    RelationChange,
    TechUnlock,
    SpawnEntity,
    DestroyEntity,
    ModifyStat,
    TriggerStoryArc,
    EndStoryArc,
    DeclareWar,
    DeclarePeace,
    FormAlliance,
    PopulationChange,
    MoraleChange,
    Custom
}

/// <summary>
/// A requirement that must be met to select a choice.
/// </summary>
public record EventRequirement(
    RequirementType Type,
    Dictionary<string, object> Parameters
)
{
    public bool IsMet(Empire.Empire empire)
    {
        return Type switch
        {
            RequirementType.MinCredits => empire.Treasury.Credits >= (decimal)Parameters["Amount"],
            RequirementType.HasTechnology => empire.HasTechnology((Guid)Parameters["TechId"]),
            RequirementType.MinReputation => empire.DiplomaticReputation >= (int)Parameters["MinRep"],
            RequirementType.AtWar => empire.Relations.Any(r => r.Type == Empire.RelationType.War),
            RequirementType.AtPeace => !empire.Relations.Any(r => r.Type == Empire.RelationType.War),
            _ => true
        };
    }

    public static EventRequirement MinCredits(decimal amount) =>
        new(RequirementType.MinCredits, new Dictionary<string, object> { ["Amount"] = amount });

    public static EventRequirement HasTech(Guid techId) =>
        new(RequirementType.HasTechnology, new Dictionary<string, object> { ["TechId"] = techId });
}

public enum RequirementType
{
    MinCredits,
    MinDilithium,
    HasTechnology,
    MinReputation,
    MaxReputation,
    AtWar,
    AtPeace,
    ControlsSystem,
    HasFleetStrength,
    Custom
}

public enum EventCategory
{
    Exploration,
    Diplomatic,
    Military,
    Economic,
    Research,
    Political,
    Humanitarian,
    Crisis,
    Opportunity,
    Special,
    Population,
    Narrative
}

public enum EventScope
{
    Local,      // Single system
    Regional,   // Multiple systems, one empire mainly
    Bilateral,  // Two empires
    Galactic,   // Everyone affected
    Hidden,     // Only visible to certain empires
    Galaxy,     // Alias for Galactic
    MultiSystem,
    System,
    Empire,
    Colony
}

/// <summary>
/// A multi-event story arc that unfolds over time.
/// Like the Dominion War or a Borg invasion campaign.
/// </summary>
public class StoryArc : Entity
{
    private readonly List<StoryChapter> _chapters = new();
    private int _currentChapterIndex = 0;

    public string Name { get; private set; }
    public string Description { get; private set; }
    public StoryScale Scale { get; private set; }
    public bool IsComplete { get; private set; }
    public int TurnStarted { get; private set; }

    public IReadOnlyList<StoryChapter> Chapters => _chapters.AsReadOnly();
    public StoryChapter? CurrentChapter => _currentChapterIndex < _chapters.Count
        ? _chapters[_currentChapterIndex]
        : null;

    private StoryArc() { }

    public StoryArc(string name, string description, StoryScale scale)
    {
        Name = name;
        Description = description;
        Scale = scale;
    }

    /// <summary>
    /// Constructor with turn info for generated arcs
    /// </summary>
    public StoryArc(string name, string description, int turnStarted, int duration)
    {
        Name = name;
        Description = description;
        Scale = StoryScale.Quest;
        TurnStarted = turnStarted;
        _duration = duration;
    }
    
    private int _duration = 20;

    /// <summary>
    /// Process a turn and potentially generate an event
    /// </summary>
    public GameEvent? ProcessTurn(int currentTurn)
    {
        if (IsComplete)
            return null;
            
        var turnsElapsed = currentTurn - TurnStarted;
        
        // Check if arc should complete
        if (turnsElapsed >= _duration)
        {
            IsComplete = true;
            return new GameEvent(
                $"{Name} Concludes",
                $"The {Name} storyline has reached its conclusion.",
                EventCategory.Narrative,
                EventScope.Galaxy);
        }
        
        // Use Evaluate for chapter-based arcs
        var events = Evaluate(new GameState { TurnNumber = currentTurn }).ToList();
        return events.FirstOrDefault();
    }

    public void AddChapter(StoryChapter chapter)
    {
        _chapters.Add(chapter);
    }

    public IEnumerable<GameEvent> Evaluate(GameState state)
    {
        if (IsComplete || CurrentChapter == null)
            yield break;

        // Check if current chapter conditions are met
        if (CurrentChapter.ShouldTrigger(state))
        {
            yield return CurrentChapter.GenerateEvent(state);

            if (CurrentChapter.IsComplete)
            {
                _currentChapterIndex++;
                if (_currentChapterIndex >= _chapters.Count)
                {
                    IsComplete = true;
                }
            }
        }
    }

    // Factory methods for major story arcs
    public static StoryArc CreateBorgInvasionArc()
    {
        var arc = new StoryArc(
            "The Borg Invasion",
            "The Borg have come. Resistance may be futile, but you must try.",
            StoryScale.Crisis);

        arc.AddChapter(new StoryChapter(
            "First Contact",
            state => true,  // Triggers immediately
            state => new GameEvent(
                "Borg Cube Detected",
                "A Borg cube has entered the quadrant. Long-range sensors confirm: they are heading for populated space.",
                EventCategory.Crisis,
                EventScope.Galactic)));

        arc.AddChapter(new StoryChapter(
            "The Battle",
            state => state.TurnNumber > 5,  // After some buildup
            state => new GameEvent(
                "The Borg Engage",
                "The cube has reached the first major colony. They demand surrender. Resistance is forming.",
                EventCategory.Military,
                EventScope.Galactic)));

        // More chapters...

        return arc;
    }

    public static StoryArc CreateDominionColdWarArc()
    {
        var arc = new StoryArc(
            "The Dominion Threat",
            "First contact with the Dominion changes everything.",
            StoryScale.Large);

        arc.AddChapter(new StoryChapter(
            "Through the Wormhole",
            state => true,
            state => new GameEvent(
                "Stable Wormhole Confirmed",
                "The Bajoran wormhole leads to the Gamma Quadrant - and something waits on the other side.",
                EventCategory.Exploration,
                EventScope.Galactic)));

        // More chapters...

        return arc;
    }
}

/// <summary>
/// A single chapter/stage of a story arc.
/// </summary>
public class StoryChapter
{
    public string Name { get; }
    private readonly Func<GameState, bool> _triggerCondition;
    private readonly Func<GameState, GameEvent> _eventGenerator;
    public bool IsComplete { get; private set; }

    public StoryChapter(
        string name,
        Func<GameState, bool> triggerCondition,
        Func<GameState, GameEvent> eventGenerator)
    {
        Name = name;
        _triggerCondition = triggerCondition;
        _eventGenerator = eventGenerator;
    }

    public bool ShouldTrigger(GameState state) => !IsComplete && _triggerCondition(state);

    public GameEvent GenerateEvent(GameState state)
    {
        IsComplete = true;
        return _eventGenerator(state);
    }
}

public enum StoryScale
{
    Minor,      // Small subplot
    Medium,     // Regional arc
    Quest,      // Personal or small-scale story
    Large,      // Major arc affecting multiple empires
    Crisis      // Game-defining threat
}

/// <summary>
/// Snapshot of game state for event evaluation.
/// </summary>
public class GameState
{
    public int TurnNumber { get; init; }
    public List<Empire.Empire> Empires { get; init; } = new();
    public List<Galaxy.StarSystem> Systems { get; init; } = new();
    public List<Military.Fleet> Fleets { get; init; } = new();

    // Computed properties for event evaluation
    public bool HasActiveWar => Empires.Any(e =>
        e.Relations.Any(r => r.Type == Empire.RelationType.War));

    public int AverageTechLevel { get; init; }
    public Dictionary<Guid, int> EmpirePowerRankings { get; init; } = new();
    
    // Additional properties needed by NarrativeEngine
    public int TotalEmpires => Empires.Count;
    public double AverageMilitaryPower => Fleets.Any() ? Fleets.Average(f => f.Ships.Count * 10) : 0;
}

/// <summary>
/// Metrics the Game Master tracks to make decisions.
/// </summary>
public class GameStateMetrics
{
    public double PowerBalance { get; private set; }         // How even is power distribution
    public int DiplomaticTension { get; private set; }       // 0-100, higher = more likely conflict
    public int ChaosLevel { get; private set; }              // 0-100, how much is happening
    public int TechLevel { get; private set; }               // Average tech advancement
    public bool IsGameStagnant { get; private set; }         // Nothing interesting happening
    public bool HasBorgPresence { get; private set; }
    public bool HasWeakMajorPower { get; private set; }
    public bool HasRecentWar { get; private set; }
    public bool HasLargeFleets { get; private set; }
    public bool HasOccupiedTerritories { get; private set; }
    public bool HasNeutralZones { get; private set; }
    public bool HasBajor { get; private set; }
    public int KlingonStability { get; private set; }
    public bool HasUnstableEmpire { get; private set; }

    public List<Guid> StrugglingEmpires { get; } = new();
    public List<Guid> DominantEmpires { get; } = new();

    public void Update(GameState state)
    {
        // Calculate power distribution
        var powers = state.EmpirePowerRankings.Values.ToList();
        if (powers.Any())
        {
            var maxPower = powers.Max();
            var minPower = powers.Min();
            var avgPower = powers.Average();

            PowerBalance = maxPower > 0 ? minPower / (double)maxPower * 100 : 100;

            // Identify struggling and dominant empires
            StrugglingEmpires.Clear();
            DominantEmpires.Clear();

            foreach (var (empireId, power) in state.EmpirePowerRankings)
            {
                if (power < avgPower * 0.5)
                    StrugglingEmpires.Add(empireId);
                else if (power > avgPower * 1.5)
                    DominantEmpires.Add(empireId);
            }
        }

        // Diplomatic tension from relations
        var warCount = state.Empires.Sum(e =>
            e.Relations.Count(r => r.Type == Empire.RelationType.War));
        var rivalCount = state.Empires.Sum(e =>
            e.Relations.Count(r => r.Type == Empire.RelationType.Rival));

        DiplomaticTension = Math.Min(100, warCount * 20 + rivalCount * 5);
        HasRecentWar = warCount > 0;

        // Stagnation detection
        IsGameStagnant = DiplomaticTension < 20 && PowerBalance > 80;

        // Tech level average
        TechLevel = state.AverageTechLevel;

        // Other flags would be calculated from actual game state...
        HasLargeFleets = state.Fleets.Any(f => f.Ships.Count > 20);
    }
}

/// <summary>
/// Interface for analyzing game state for narrative purposes.
/// </summary>
public interface IGameStateAnalyzer
{
    GameAnalysis Analyze(GameState state);
}

/// <summary>
/// Analysis results for narrative engine.
/// </summary>
public class GameAnalysis
{
    public double GameProgress { get; init; }
    public bool IsStagnant { get; init; }
    public int TurnsSinceLastCrisis { get; init; }
    public bool HasWormholeDiscovered { get; init; }
    public int AnomaliesResearched { get; init; }
    public IReadOnlyList<RegionAnalysis> Regions { get; init; } = Array.Empty<RegionAnalysis>();
    public IReadOnlyList<EmpireAnalysis> Empires { get; init; } = new List<EmpireAnalysis>();
}

/// <summary>
/// Analysis of a galactic region.
/// </summary>
public class RegionAnalysis
{
    public Guid RegionId { get; init; }
    public string Name { get; init; } = string.Empty;
    public int SystemCount { get; init; }
    public bool IsContested { get; init; }
    public List<Guid> ControllingEmpires { get; init; } = new();
}

/// <summary>
/// Analysis of an empire's current state.
/// </summary>
public class EmpireAnalysis
{
    public Guid EmpireId { get; init; }
    public string Name { get; init; } = string.Empty;
    public int PowerRank { get; init; }
    public double DominanceScore { get; init; }
    public int UnrestLevel { get; init; }
    public bool IsActive { get; init; }
}
